# é—®é¢˜å®šä¹‰

- äºŒç»´ç©ºé—´ç»™å®šèµ·ç‚¹å’Œç›®æ ‡ç‚¹

`Star_Pose = [0, 0]`
`End_Pose = [2, 2]`

- åœ¨`[[0.5, 0.75], [1.5, 1.25]]`å¤„æœ‰ä¸¤ä¸ªç‚¹éšœç¢,

`Obs_Pose=[[0.5, 0.75], [1.5, 1.25]]`

**æ±‚è§£è¿æ¥èµ·ç‚¹å’Œç›®æ ‡ç‚¹ä¸”ä¸ä¸éšœç¢å‘ç”Ÿç¢°æ’çš„è·¯å¾„ç‚¹åºåˆ—**

# é—®é¢˜æè¿°

## æ¡ä»¶ 

éœ€è¦åœ¨èµ·ç‚¹å’Œç›®æ ‡ç‚¹ä¹‹é—´ç”ŸæˆæŒ‡å®š`SIZE=n`ä¸ªè·¯å¾„ç‚¹

## çº¦æŸ

- ç”Ÿæˆçš„è·¯å¾„ç‚¹æ„æˆçš„æ€»é•¿åº¦å°½é‡çŸ­
- ç”Ÿæˆçš„è·¯å¾„ç‚¹éšœç¢ç‰©ä¿æŒå®‰å…¨è·ç¦»`Safe_Dis = 0.3m`


# æœ€å°äºŒä¹˜æ ¼å¼æ•°å­¦æè¿°

## å˜é‡å®šä¹‰

- å®šä¹‰è·¯å¾„åºåˆ— $\mathbf{X} = \{ \mathbf{x}_i \}_{i=0}^{n+1}$ï¼Œå…¶ä¸­ $\mathbf{x}_i = [x_i, y_i]$ è¡¨ç¤ºç¬¬ $i$ ä¸ªè·¯å¾„ç‚¹çš„ä½ç½®ï¼Œæ»¡è¶³ä»¥ä¸‹è¾¹ç•Œæ¡ä»¶ï¼š

$$
\mathbf{x}_0 = [0, 0], \quad \mathbf{x}_{n+1} = [2, 2]
$$

- å®šä¹‰éšœç¢åºåˆ—$\mathbf{O}=\{\mathbf{o}_j \}_{j=0}^m$ï¼Œå…¶ä¸­ $\mathbf{o}_j = [x_j, y_j]$ è¡¨ç¤ºç¬¬ $j$ ä¸ªéšœç¢ç‚¹çš„ä½ç½®

## æœ€å°äºŒä¹˜ç›®æ ‡å‡½æ•°

æœ€å°åŒ–ä»¥ä¸‹ç›®æ ‡å‡½æ•°ï¼š

$$
\min \bigg\{ \sum_{i=1}^{n+1} \big[(x_i - x_{i-1})^2 + (y_i - y_{i-1})^2\big] + \lambda \sum_{i=0}^{n+1} \max\big(0, Safe\_Dis - d_{i}\big)^2 \bigg\}
$$

å…¶ä¸­ï¼š
- $d_{i} = min_{j=0}^m \big\{ \sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}\big\}$ æ˜¯è½¨è¿¹ç‚¹ $\mathbf{x}_i$ åˆ°éšœç¢åºåˆ—$\mathbf{O}$ çš„æœ€è¿‘è·ç¦»
- $\lambda > 0$ æ˜¯å¹³è¡¡è·¯å¾„é•¿åº¦å’Œå®‰å…¨è·ç¦»çš„æƒé‡ç³»æ•°

## å¾…æ±‚è§£å˜é‡

$\mathbf{X} = \{ \mathbf{x}_i \}_{i=1}^{n}$

## çº¦æŸæ¡ä»¶

1. **è¾¹ç•Œæ¡ä»¶**ï¼š

$$
   \mathbf{x}_0 = [0, 0], \quad \mathbf{x}_{n+1} = [2, 2]
$$

3. **å®‰å…¨è·ç¦»çº¦æŸ**ï¼ˆå·²åŒ…å«åœ¨ç›®æ ‡å‡½æ•°ä¸­ï¼‰ï¼š

 $$
d_{i} = min_{j=0}^m \big\{ \sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}\big\} 
$$

# `code`

## å®šä¹‰é—®é¢˜å‚æ•°

```python
"""
é—®é¢˜å‚æ•°
    èµ·ç‚¹ä½ç½®, ç›®æ ‡ç‚¹ä½ç½®, éšœç¢åºåˆ—, å®‰å…¨è·ç¦», ä»£æ’å…¥è·¯å¾„ç‚¹æ•°é‡
"""
start_pose = np.array([0, 0])
end_pose = np.array([2, 2])
obs_pose = np.array([[0.5, 0.75], [1.5, 1.25]])
safe_dis = 0.3  
size = 25  
```

## æ„é€ ç›®æ ‡å‡½æ•°

ä½¿ç”¨`scipy`çš„`least_squares`

```python
from scipy.optimize import least_squares
```

`least_squares`å¯¹ç›®æ ‡å‡½æ•°è¦æ±‚ä¸º
1. **ä¼˜åŒ–å™¨çš„è¾“å…¥è¦æ±‚**
  è¦æ±‚è¾“å…¥å‚æ•°æ˜¯ä¸€ç»´æ•°ç»„ï¼ˆå‘é‡ï¼‰ã€‚è¿™æ˜¯å› ä¸ºä¼˜åŒ–å™¨å†…éƒ¨ä½¿ç”¨çš„æ•°å­¦è¿ç®—ï¼ˆå¦‚æ¢¯åº¦è®¡ç®—ã€è¿­ä»£æ›´æ–°ï¼‰é€šå¸¸åŸºäºå‘é‡å½¢å¼å®ç°
2. **è¿”å›æ®‹å·®å‘é‡**
  ç›®æ ‡å‡½æ•°å¿…é¡»è¿”å›ä¸€ä¸ªä¸€ç»´æ•°ç»„ï¼ˆæ®‹å·®å‘é‡ï¼‰ï¼Œè€Œä¸æ˜¯æ ‡é‡å€¼ã€‚ä¼˜åŒ–å™¨ä¼šæœ€å°åŒ–è¿™ä¸ªæ®‹å·®å‘é‡çš„å¹³æ–¹å’Œï¼ˆå³æœ€å°äºŒä¹˜é—®é¢˜çš„ç›®æ ‡ï¼‰ï¼š
3. **å‚æ•°é¡ºåº**
  ç›®æ ‡å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»æ˜¯å¾…ä¼˜åŒ–çš„å˜é‡ï¼ˆå³éœ€è¦è°ƒæ•´ä»¥æœ€å°åŒ–æ®‹å·®çš„å‚æ•°ï¼‰ã€‚å…¶ä»–å‚æ•°ï¼ˆå¦‚æƒé‡ï¼‰å¯ä»¥é€šè¿‡ args å‚æ•°ä¼ å…¥ï¼š

æ‰€ä»¥ç›®æ ‡å‡½æ•°è¾“å…¥è®¾ç½®ä¸º $\mathbf{X} = \{ \mathbf{x}_i \}_{i=1}^{n}$ ä¸€ç»´é™ç»´æ ¼å¼, 
æ­¤å¤–ç›®æ ‡å‡½æ•°ä¸­çš„ $\lambda > 0$ ä¹Ÿå¯ä»¥ä½œä¸ºå…¶ä»–å‚æ•°ä¼ å…¥,
æœ€ç»ˆå‡½æ•°è¿”å›ä¸€ç»´æ®‹å·®å‘é‡

```python
def objective_function(params, lambda_weight=100):
    """æ„å»ºæœ€å°äºŒä¹˜é—®é¢˜çš„ç›®æ ‡å‡½æ•°"""
    # é‡å¡‘å‚æ•°ä¸ºè½¨è¿¹ç‚¹(ä¸€ç»´->äºŒç»´)
    trajectory = params.reshape(-1, 2)
    
    # æ„å»ºå®Œæ•´è½¨è¿¹ï¼ˆåŒ…æ‹¬èµ·ç‚¹å’Œç»ˆç‚¹ï¼‰
    full_trajectory = np.vstack((start_pose, trajectory, end_pose))
    
    # 1. è·¯å¾„é•¿åº¦é¡¹ï¼ˆç›¸é‚»ç‚¹ä¹‹é—´çš„æ¬§æ°è·ç¦»ï¼‰
    path_length_terms = []
    for i in range(1, len(full_trajectory)):
        dx = full_trajectory[i, 0] - full_trajectory[i-1, 0]
        dy = full_trajectory[i, 1] - full_trajectory[i-1, 1]
        path_length_terms.append(np.sqrt(dx**2 + dy**2))
    
    # 2. å®‰å…¨è·ç¦»çº¦æŸé¡¹ï¼ˆå¯¹æ¯ä¸ªéšœç¢ç‰©éƒ½è®¡ç®—ï¼‰
    safety_terms = []
    for point in full_trajectory:
        # è®¡ç®—åˆ°æ¯ä¸ªéšœç¢ç‰©çš„è·ç¦»ï¼Œå–æœ€å°è·ç¦»ï¼ˆæœ€å±é™©çš„éšœç¢ç‰©ï¼‰
        min_dist_to_obs = min(np.linalg.norm(point - obs) for obs in obs_pose)
        # å½“æœ€å°è·ç¦»å°äºå®‰å…¨è·ç¦»æ—¶æ–½åŠ æƒ©ç½š
        safety_violation = max(0, safe_dis - min_dist_to_obs)
        safety_terms.append(safety_violation)
    
    # 3. ç»„åˆæ‰€æœ‰é¡¹
    residuals = []
    residuals.extend(path_length_terms)  # è·¯å¾„é•¿åº¦é¡¹
    residuals.extend([lambda_weight * s for s in safety_terms])  # å®‰å…¨çº¦æŸé¡¹ï¼ˆå¸¦æƒé‡ï¼‰
    
    return np.array(residuals)
```

### ç”Ÿæˆåˆå§‹è·¯å¾„

ä¸ºäº†æé«˜ä¼˜åŒ–æˆåŠŸç‡, åˆå§‹åŒ–ä¸€æ¡èµ·ç‚¹è¿æ¥ç›®æ ‡ç‚¹çš„çº¿æ€§è·¯å¾„åºåˆ—

```python
# ç”Ÿæˆçº¿æ€§æ’å€¼çš„åˆå§‹çŒœæµ‹
def generate_linear_initial_guess():
    """ç”Ÿæˆçº¿æ€§æ’å€¼çš„åˆå§‹çŒœæµ‹"""
    initial_guess = np.zeros((size, 2))
    for i in range(size):
        ratio = (i + 1) / (size + 1)
        point = start_pose + ratio * (end_pose - start_pose)
        initial_guess[i] = point
    return initial_guess
```

## æ±‚è§£



```python
if __name__ == '__main__':
    # ç”Ÿæˆåˆå§‹çŒœæµ‹ï¼ˆçº¿æ€§æ’å€¼ï¼‰
    initial_guess = generate_linear_initial_guess()
    initial_guess_flat = initial_guess.flatten()

    result = least_squares(
        objective_function,
        initial_guess_flat,
        method='trf',
        args=(500,),
        verbose=1,
        ftol=1e-8,
        xtol=1e-8,
        max_nfev=1000,
        bounds=(-10, 10)
        )
```

| å‚æ•°               | ä½œç”¨                                                                 | ç¤ºä¾‹/é»˜è®¤å€¼                          | è°ƒæ•´å»ºè®®                                                                 |
|--------------------|----------------------------------------------------------------------|---------------------------------------|--------------------------------------------------------------------------|
| `objective_function` | ç›®æ ‡å‡½æ•°ï¼Œè¿”å›æ®‹å·®å‘é‡ï¼ˆä¸€ç»´æ•°ç»„ï¼‰ï¼Œä¼˜åŒ–å™¨æœ€å°åŒ–æ®‹å·®çš„å¹³æ–¹å’Œ          | `def objective(params, ...): ...`     | ç¡®ä¿æ®‹å·®å‘é‡åˆç†åæ˜ è·¯å¾„é•¿åº¦å’Œçº¦æŸè¿åç¨‹åº¦                              |
| `initial_guess_flat` | ä¼˜åŒ–å˜é‡çš„åˆå§‹çŒœæµ‹å€¼ï¼ˆä¸€ç»´æ•°ç»„ï¼‰ï¼Œç®—æ³•ä»è¯¥ç‚¹å¼€å§‹æœç´¢                   | `initial_guess.flatten()`             | åˆå§‹å€¼å½±å“æ”¶æ•›é€Ÿåº¦å’Œç»“æœè´¨é‡ï¼Œå¯å°è¯•ä¸åŒåˆå§‹åŒ–ç­–ç•¥                      |
| `method='trf'`     | ä¼˜åŒ–ç®—æ³•ç±»å‹ï¼Œ`'trf'` æ”¯æŒè¾¹ç•Œçº¦æŸï¼Œé€‚ç”¨äºå¤§è§„æ¨¡éçº¿æ€§é—®é¢˜               | `'trf'`ï¼ˆé»˜è®¤ï¼‰ã€`'dogbox'`ã€`'lm'`   | å¸¦çº¦æŸé—®é¢˜é¦–é€‰ `'trf'`ï¼Œæ— çº¦æŸé—®é¢˜å¯ç”¨ `'lm'`                            |
| `args=(500,)`      | ä¼ é€’ç»™ç›®æ ‡å‡½æ•°çš„é¢å¤–å‚æ•°ï¼ˆå…ƒç»„å½¢å¼ï¼‰ï¼Œå¦‚å®‰å…¨çº¦æŸæƒé‡                     | `(lambda_weight,)`                    | å¢å¤§æƒé‡å¼ºåŒ–å®‰å…¨çº¦æŸï¼Œå‡å°æƒé‡ä¼˜å…ˆç¼©çŸ­è·¯å¾„                              |
| `verbose=1`        | æ§åˆ¶ä¼˜åŒ–è¿‡ç¨‹çš„è¾“å‡ºè¯¦ç»†ç¨‹åº¦                                              | `0`ï¼ˆæ— è¾“å‡ºï¼‰ã€`1`ï¼ˆè¿­ä»£ä¿¡æ¯ï¼‰ã€`2`ï¼ˆè¯¦ç»†è¿‡ç¨‹ï¼‰ | è°ƒè¯•æ—¶ç”¨ `2`ï¼Œç”Ÿäº§ç¯å¢ƒç”¨ `0` æˆ– `1`                                      |
| `ftol=1e-8`        | å‡½æ•°æ”¶æ•›å®¹å·®ï¼Œæ®‹å·®å‘é‡çš„ç›¸å¯¹å˜åŒ–å°äºæ­¤å€¼æ—¶åœæ­¢è¿­ä»£                      | `1e-8`                                | è‹¥ä¼˜åŒ–è¿‡æ—©åœæ­¢ï¼Œå‡å°å®¹å·®ï¼›è‹¥è€—æ—¶è¿‡é•¿ï¼Œå¢å¤§å®¹å·®                          |
| `xtol=1e-8`        | å˜é‡æ”¶æ•›å®¹å·®ï¼Œä¼˜åŒ–å˜é‡çš„ç›¸å¯¹å˜åŒ–å°äºæ­¤å€¼æ—¶åœæ­¢è¿­ä»£                      | `1e-8`                                | åŒä¸Š                                                                     |
| `max_nfev=1000`    | æœ€å¤§å‡½æ•°è¯„ä¼°æ¬¡æ•°ï¼Œé˜²æ­¢ç®—æ³•æ— é™å¾ªç¯                                        | `1000`                                | å¤æ‚é—®é¢˜å¯å¢åŠ æ­¤å€¼ï¼ˆå¦‚ `2000`ï¼‰                                          |
| `bounds=(-10, 10)` | ä¼˜åŒ–å˜é‡çš„è¾¹ç•Œçº¦æŸï¼Œç¡®ä¿å‚æ•°å€¼åœ¨åˆç†èŒƒå›´å†…                                | `(-10, 10)`                           | æ ¹æ®é—®é¢˜è§„æ¨¡è°ƒæ•´ï¼Œç¡®ä¿è¦†ç›–æ‰€æœ‰å¯èƒ½çš„è½¨è¿¹ç‚¹ä½ç½®                          |

## ç»“æœ

| <img  src="picture/size5.png" width="400" />  | <img  src="picture/size25.png" width="400" /> | 
| --- | --- | 
|`SIZE=5`,`Safe_Dis = 0.3m`|`SIZE=25`,`Safe_Dis = 0.3m`|
| <img  src="picture/size25_safe0.55.png" width="400" /> | <img  src="picture/size25_safe0.6.png" width="400" />  | 
|`SIZE=25`,`Safe_Dis = 0.55m`|`SIZE=25`,`Safe_Dis = 0.6m`|
- æ’å…¥ç‚¹è¿‡å°‘æ—¶ï¼Œç”Ÿæˆè·¯å¾„ä¸è¿è´¯
- å®‰å…¨è·ç¦»è¿‡å¤§æ—¶ï¼Œå¯¼è‡´éšœç¢é™„è¿‘è·¯å¾„ç‚¹åˆ†å¸ƒç¨€ç–

### ä¸€äº›ä¿®æ”¹å»ºè®®â˜ï¸

- æ·»åŠ ç›¸é‚»è·¯å¾„ç‚¹è·ç¦»çº¦æŸï¼Œå¯¹äºç›¸é‚»è·¯å¾„ç‚¹è¿‡è¿œæƒ…å†µæ–½åŠ çº¦æŸï¼Œä¿è¯è·¯å¾„ç‚¹åˆ†å¸ƒçš„å‡åŒ€æ€§

### `cost`è®¡ç®—ç»†èŠ‚ğŸ¤Œ

åœ¨é—®é¢˜ä¸­ï¼Œ`result.cost` æ˜¯æœ€å°äºŒä¹˜ä¼˜åŒ–çš„ç›®æ ‡å‡½æ•°å€¼ï¼ˆæ®‹å·®å¹³æ–¹å’Œçš„ä¸€åŠï¼‰ï¼Œå…¶æœ€å°å€¼å–å†³äº **è·¯å¾„é•¿åº¦** å’Œ **å®‰å…¨çº¦æŸæƒ©ç½š** çš„å¹³è¡¡ï¼Œæ²¡æœ‰å›ºå®šçš„ç†è®ºæœ€å°å€¼ã€‚ä»¥ä¸‹æ˜¯å…·ä½“åˆ†æï¼š


###  `result.cost` çš„è®¡ç®—å…¬å¼
`result.cost` ç”± `scipy.optimize.least_squares` è‡ªåŠ¨è®¡ç®—ï¼Œç­‰äºæ®‹å·®å‘é‡å¹³æ–¹å’Œçš„ä¸€åŠï¼š

$$
\text{result.cost} = 0.5 \times \sum_{i=1}^{m} r_i^2
$$

å…¶ä¸­ \( r_i \) æ˜¯ç›®æ ‡å‡½æ•°è¿”å›çš„æ®‹å·®å‘é‡å…ƒç´ ï¼ˆåŒ…å«è·¯å¾„é•¿åº¦é¡¹å’Œå®‰å…¨çº¦æŸé¡¹ï¼‰ã€‚

ä¾‹å¦‚ï¼Œå½“ size=25 æ—¶ï¼Œç›´çº¿è¢«åˆ†ä¸º 26 æ®µï¼Œæ¯æ®µè·ç¦»çº¦ 2.828/26â‰ˆ0.109ï¼Œåˆ™ï¼š

$$
cost_{min}â€‹â‰ˆ0.5Ã—26Ã—(0.109)^2â‰ˆ0.5Ã—26Ã—0.0119â‰ˆ0.155
$$

# é™„å½•

## å®Œæ•´ä»£ç 

<details> <summary>å®Œæ•´ä»£ç </summary>
<pre><code> 
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import least_squares
import time  

"""
é—®é¢˜å‚æ•°
    èµ·ç‚¹ä½ç½®, ç›®æ ‡ç‚¹ä½ç½®, éšœç¢åºåˆ—, å®‰å…¨è·ç¦», ä»£æ’å…¥è·¯å¾„ç‚¹æ•°é‡
"""
start_pose = np.array([0, 0])
end_pose = np.array([2, 2])
obs_pose = np.array([[0.5, 0.75], [1.5, 1.25]])
safe_dis = 0.5
size = 25  


def compute_safety_violation(trajectory):
    """è®¡ç®—è·¯å¾„ç‚¹åˆ°æ‰€æœ‰éšœç¢çš„æœ€å°è·ç¦»ï¼Œè¯„ä¼°å®‰å…¨çº¦æŸè¿åç¨‹åº¦"""
    min_dist = float('inf')
    for point in trajectory:
        # è®¡ç®—åˆ°æ¯ä¸ªéšœç¢ç‰©çš„è·ç¦»ï¼Œå–æœ€å°å€¼
        dist_to_obs = min(np.linalg.norm(point - obs) for obs in obs_pose)
        if dist_to_obs < min_dist:
            min_dist = dist_to_obs
    return min_dist - safe_dis  # å°äº0è¡¨ç¤ºå­˜åœ¨å®‰å…¨çº¦æŸè¿å

def objective_function(params, lambda_weight=100):
    """æ„å»ºæœ€å°äºŒä¹˜é—®é¢˜çš„ç›®æ ‡å‡½æ•°"""
    # é‡å¡‘å‚æ•°ä¸ºè½¨è¿¹ç‚¹(ä¸€ç»´->äºŒç»´)
    trajectory = params.reshape(-1, 2)
    
    # æ„å»ºå®Œæ•´è½¨è¿¹ï¼ˆåŒ…æ‹¬èµ·ç‚¹å’Œç»ˆç‚¹ï¼‰
    full_trajectory = np.vstack((start_pose, trajectory, end_pose))
    
    # 1. è·¯å¾„é•¿åº¦é¡¹ï¼ˆç›¸é‚»ç‚¹ä¹‹é—´çš„æ¬§æ°è·ç¦»ï¼‰
    path_length_terms = []
    for i in range(1, len(full_trajectory)):
        dx = full_trajectory[i, 0] - full_trajectory[i-1, 0]
        dy = full_trajectory[i, 1] - full_trajectory[i-1, 1]
        path_length_terms.append(np.sqrt(dx**2 + dy**2))
    
    # 2. å®‰å…¨è·ç¦»çº¦æŸé¡¹ï¼ˆå¯¹æ¯ä¸ªéšœç¢ç‰©éƒ½è®¡ç®—ï¼‰
    safety_terms = []
    for point in full_trajectory:
        # è®¡ç®—åˆ°æ¯ä¸ªéšœç¢ç‰©çš„è·ç¦»ï¼Œå–æœ€å°è·ç¦»ï¼ˆæœ€å±é™©çš„éšœç¢ç‰©ï¼‰
        min_dist_to_obs = min(np.linalg.norm(point - obs) for obs in obs_pose)
        # å½“æœ€å°è·ç¦»å°äºå®‰å…¨è·ç¦»æ—¶æ–½åŠ æƒ©ç½š
        safety_violation = max(0, safe_dis - min_dist_to_obs)
        safety_terms.append(safety_violation)
    
    # 3. ç»„åˆæ‰€æœ‰é¡¹
    residuals = []
    residuals.extend(path_length_terms)  # è·¯å¾„é•¿åº¦é¡¹
    residuals.extend([lambda_weight * s for s in safety_terms])  # å®‰å…¨çº¦æŸé¡¹ï¼ˆå¸¦æƒé‡ï¼‰
    
    return np.array(residuals)

def visualize_trajectory(result, initial_guess):
    """å¯è§†åŒ–è½¨è¿¹è§„åˆ’ç»“æœï¼ˆæ”¯æŒå¤šä¸ªéšœç¢ç‰©ï¼‰"""
    # æå–ä¼˜åŒ–åçš„è½¨è¿¹ç‚¹
    trajectory = result.x.reshape(-1, 2)
    full_trajectory = np.vstack((start_pose, trajectory, end_pose))
    
    # æå–åˆå§‹çŒœæµ‹è½¨è¿¹
    initial_trajectory = initial_guess.reshape(-1, 2)
    initial_full = np.vstack((start_pose, initial_trajectory, end_pose))
    
    # åˆ›å»ºå›¾å½¢
    plt.figure(figsize=(12, 10))
    
    # ç»˜åˆ¶åˆå§‹çŒœæµ‹è½¨è¿¹ï¼ˆç°è‰²è™šçº¿ï¼‰
    plt.plot(initial_full[:, 0], initial_full[:, 1], 'o--', color='gray', alpha=0.5, label='Initial Guess (Linear)')
    
    # ç»˜åˆ¶ä¼˜åŒ–åçš„è½¨è¿¹
    plt.plot(full_trajectory[:, 0], full_trajectory[:, 1], 'o-', color='blue', label='Optimized Trajectory')
    
    # ç»˜åˆ¶èµ·ç‚¹å’Œç»ˆç‚¹
    plt.plot(start_pose[0], start_pose[1], 'go', markersize=12, label='Start')
    plt.plot(end_pose[0], end_pose[1], 'ro', markersize=12, label='End')
    
    # ç»˜åˆ¶æ‰€æœ‰éšœç¢ç‰©åŠå…¶å®‰å…¨åŒºåŸŸ
    for obs in obs_pose:
        # å®‰å…¨åŒºåŸŸï¼ˆè™šçº¿åœ†ï¼‰
        circle = plt.Circle(obs, safe_dis, color='r', fill=False, linestyle='--')
        plt.gca().add_patch(circle)
        # éšœç¢ç‰©æœ¬èº«ï¼ˆé»‘è‰²æ–¹å—ï¼‰
        plt.plot(obs[0], obs[1], 'ks', markersize=12, label='Obstacle' if obs is obs_pose[0] else "")
    
    # æ·»åŠ æ ‡ç­¾å’Œå›¾ä¾‹
    plt.grid(True)
    plt.axis('equal')
    plt.xlabel('X Coordinate', fontsize=12)
    plt.ylabel('Y Coordinate', fontsize=12)
    plt.title(f'Trajectory Planning with Multiple Obstacles (Inserted Points: {size}, Safety Distance: {safe_dis}m)', fontsize=14)
    plt.legend(fontsize=12)
    
    # æ˜¾ç¤ºä¼˜åŒ–ç»“æœ
    safety_violation = compute_safety_violation(full_trajectory)
    plt.text(0.05, 0.95, f'Optimization Status: {result.message}', transform=plt.gca().transAxes, fontsize=12)
    plt.text(0.05, 0.90, f'Function Evaluations: {result.nfev}', transform=plt.gca().transAxes, fontsize=12)
    plt.text(0.05, 0.85, f'Final Cost: {result.cost:.6f}', transform=plt.gca().transAxes, fontsize=12)
    plt.text(0.05, 0.80, f'Safety Violation: {safety_violation:.6f}', transform=plt.gca().transAxes, fontsize=12)
    
    plt.show()

# ç”Ÿæˆçº¿æ€§æ’å€¼çš„åˆå§‹çŒœæµ‹
def generate_linear_initial_guess():
    """ç”Ÿæˆçº¿æ€§æ’å€¼çš„åˆå§‹çŒœæµ‹"""
    initial_guess = np.zeros((size, 2))
    for i in range(size):
        ratio = (i + 1) / (size + 1)
        point = start_pose + ratio * (end_pose - start_pose)
        initial_guess[i] = point
    return initial_guess

if __name__ == '__main__':

    # ç”Ÿæˆåˆå§‹çŒœæµ‹ï¼ˆçº¿æ€§æ’å€¼ï¼‰
    initial_guess = generate_linear_initial_guess()
    initial_guess_flat = initial_guess.flatten()

    # è®°å½•ä¼˜åŒ–å¼€å§‹æ—¶é—´
    start_time = time.time()
    # æ‰§è¡Œä¼˜åŒ–
    result = least_squares(
        objective_function,
        initial_guess_flat,
        method='trf',
        args=(500,),
        verbose=1,
        ftol=1e-8,
        xtol=1e-8,
        max_nfev=1000,
        bounds=(-10, 10)
    )
    # è®¡ç®—ä¼˜åŒ–è€—æ—¶
    optimization_time = time.time() - start_time

    trajectory = result.x.reshape(-1, 2)
    full_trajectory = np.vstack((start_pose, trajectory, end_pose))
    safety_violation = compute_safety_violation(full_trajectory)
        
    print(f"Safety Violation: {safety_violation:.6f}")
    print(f"Optimization Time: {optimization_time:.4f} seconds")
        
    if result is not None:
        print("\nFinal Optimization Result:")
        print("Status:", result.message)
        print("Iterations:", result.nfev)
        print("Objective Function Value:", result.cost)
        visualize_trajectory(result, initial_guess)
    else:
        print("Optimization failed, no feasible solution found")
</code></pre>
</details>
