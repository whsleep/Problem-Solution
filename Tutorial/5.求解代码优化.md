# 求解代码优化

## 自适应调整轨迹长度

```python
    def _auto_size(self):
        dist = np.linalg.norm(self.end[:2] - self.start[:2])
        t_min = dist / self.vmax
        self.n = max(4, int(np.ceil(t_min * self.auto_hz)))
        print(f'[Auto] dist={dist:.2f}, t_min={t_min:.2f}, n={self.n}')
```

仅当起点和目标点的变化与原先起点和目标点相比超出阈值范围后

才进行轨迹点数量自动调整

```python
        # 2. 起点 / 终点更新 + 偏差检测
        dirty_n = False
        if start_new is not None:
            start_new = np.asarray(start_new, float)
            if (np.linalg.norm(start_new[:2] - self.start[:2]) > pos_th or
                    abs(np.arctan2(np.sin(start_new[2] - self.start[2]),
                                np.cos(start_new[2] - self.start[2]))) > ang_th):
                self.start = np.copy(start_new) 
                dirty_n = True

        if end_new is not None:
            end_new = np.asarray(end_new, float)
            if (np.linalg.norm(end_new[:2] - self.end[:2]) > pos_th or
                    abs(np.arctan2(np.sin(end_new[2] - self.end[2]),
                                np.cos(end_new[2] - self.end[2]))) > ang_th):
                self.end = np.copy(end_new) 
                dirty_n = True

        # 3. 只有起点/终点变化时才重算 n 并清空上一次解
        if dirty_n:
            self._auto_size()
            self._last_sol = None          # 强制重新生成初值
```

## 软启动

保存上次优化结果,作为本次优化初值,加速求解
(**起点和目标点在允许的变化范围内**)

```python
    def _init_guess(self):
        if self._last_sol is not None:
            return self._last_sol
        n = self.n
        return np.hstack([
            np.linspace(self.start[0], self.end[0], n+2)[1:-1],
            np.linspace(self.start[1], self.end[1], n+2)[1:-1],
            np.unwrap(np.linspace(self.start[2], self.end[2], n+2))[1:-1],
            np.full(n+1, 0.2)
        ])
```

## demo

![](picture/teb_3.gif)